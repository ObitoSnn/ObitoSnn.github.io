<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>主页</title>
    <link>https://ObitoSnn.github.io/</link>
    <description>Recent content on 主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;javascript:void(0);&#34;&gt;ObitoSnn&lt;/a&gt;
</copyright>
    <lastBuildDate>Sun, 06 Jun 2021 00:59:05 +0800</lastBuildDate><atom:link href="https://ObitoSnn.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>反射的概述</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 21 Apr 2021 14:30:27 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0/</guid>
      <description>关于反射的理解 Reflection(反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</description>
    </item>
    
    <item>
      <title>InetAddress类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/inetaddress%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 21 Apr 2021 13:39:39 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/inetaddress%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>实现网络通信需要解决的两个问题  如何准确地定位网络上一台或多台主机；定位主机上的特定应用 找到主机后如何可靠高效地进行数据传输  网络通信的两个要素  IP和端口号 提供网络通信的协议：TCP/IP参考模型（应用层、传输层、网络层、物理+链路层）  通信要素一：IP和端口号 IP的理解  唯一的标识Internet上的计算机（通信实体） 在Java中使用InetAddress类代表IP IP分类：IPv4和IPv6；万维网和局域网 域名：www.</description>
    </item>
    
    <item>
      <title>编码集</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/%E7%BC%96%E7%A0%81%E9%9B%86/</link>
      <pubDate>Tue, 20 Apr 2021 18:45:39 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/%E7%BC%96%E7%A0%81%E9%9B%86/</guid>
      <description>常见的编码集 ASCII：美国标准信息交换码。用一个字节的7位可以表示
ISO8859-1：拉丁码表。欧洲码表。用一个字节的8位表示</description>
    </item>
    
    <item>
      <title>File类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/file%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Apr 2021 11:20:50 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/file%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>File类的理解  File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹) File类声明在java.</description>
    </item>
    
    <item>
      <title>泛型的理解</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Mon, 19 Apr 2021 17:43:09 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>泛型的概念 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如：继承或实现这个接口，用这个类型声明变量、创建对象）确定（即传入实际的类型参数，也称为类型实参）
泛型引入的背景 集合容器类在设计阶段 / 声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK 1.</description>
    </item>
    
    <item>
      <title>数组与集合</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</link>
      <pubDate>Sat, 10 Apr 2021 10:21:41 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</guid>
      <description>集合与数组存储数据概述 集合、数组都是对多个数据进行存储操作的结构，简称Java容器
说明：此时的存储，主要值得是内存层面的存储，不涉及到持久化的存储（.txt，.jpg，.avi，数据库中）</description>
    </item>
    
    <item>
      <title>枚举类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 09 Apr 2021 11:49:25 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>枚举类说明  枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类 当需要定义一组常量时，强烈建议使用枚举类 如果枚举类中只有一个对象，则可以作为单例模式的实现方式  如何自定义枚举类 //自定义枚举类 class Season{ //1.</description>
    </item>
    
    <item>
      <title>String类</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/string%E7%B1%BB/</link>
      <pubDate>Mon, 05 Apr 2021 00:27:31 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/string%E7%B1%BB/</guid>
      <description>概述   String:字符串，使用一对&amp;quot;&amp;ldquo;引起来表示</description>
    </item>
    
    <item>
      <title>死锁问题</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 02 Apr 2021 11:32:02 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</guid>
      <description>死锁的理解 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁
说明  出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时，要避免出现死锁  举例 public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1) { s1.</description>
    </item>
    
    <item>
      <title>程序、进程、线程的理解</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Thu, 01 Apr 2021 20:24:56 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%A8%8B%E5%BA%8F%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>程序(program) 概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码
进程(process) 概念：程序的一次执行过程，或是正在运行的一个程序。</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Wed, 31 Mar 2021 21:10:00 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8/</guid>
      <description>异常的体系结构 * java.lang.Throwable * |-----java.</description>
    </item>
    
    <item>
      <title>代理模式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Mar 2021 21:03:41 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决的问题 代理模式是Java开发中使用较多的一种设计模式，代理设计就是为其他对象提供一种代理以控制对这个对象的访问
举例 interface NetWork{ public void browse(); } //被代理类 class Server implements NetWork{ @Override public void browse() { System.</description>
    </item>
    
    <item>
      <title>模板方法的设计模式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97abstract/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Mar 2021 20:18:44 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97abstract/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决的问题 在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式
举例 public abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.</description>
    </item>
    
    <item>
      <title>属性的赋值顺序</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%9D%97/%E5%B1%9E%E6%80%A7%E7%9A%84%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sun, 28 Mar 2021 15:09:12 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E5%9D%97/%E5%B1%9E%E6%80%A7%E7%9A%84%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F/</guid>
      <description>默认初始化 显式初始化 构造器中初始化 有了对象以后，可以通过&amp;quot;对象.</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97static/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 28 Mar 2021 13:36:36 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97static/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>设计模式的说明 理解 设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式</description>
    </item>
    
    <item>
      <title>面向对象的特征二：继承性</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%8C%E7%BB%A7%E6%89%BF%E6%80%A7/</link>
      <pubDate>Sat, 27 Mar 2021 15:25:09 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%BA%8C%E7%BB%A7%E6%89%BF%E6%80%A7/</guid>
      <description>为什么要有类的继承性？(继承性的好处）  减少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提  图示：</description>
    </item>
    
    <item>
      <title>属性赋值顺序</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Thu, 25 Mar 2021 20:15:57 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E9%A1%BA%E5%BA%8F/</guid>
      <description>属性赋值的先后顺序  默认初始化 显式初始化 构造器中初始化 通过&amp;quot;对象.</description>
    </item>
    
    <item>
      <title>关键字：return</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E5%85%B3%E9%94%AE%E5%AD%97return/</link>
      <pubDate>Sat, 27 Feb 2021 13:31:38 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E5%85%B3%E9%94%AE%E5%AD%97return/</guid>
      <description> 使用范围：使用在方法体中 作用：  结束方法 针对于返回值类型的方法，使用&amp;quot;return 数据&amp;quot;方法返回所要的数据   注意点：return关键字后面不可以声明执行语句  </description>
    </item>
    
    <item>
      <title>JVM内存结构</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 26 Feb 2021 23:18:10 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</guid>
      <description>编译完源程序以后，生成一个或多个字节码文件
我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析
《JVM规范》</description>
    </item>
    
    <item>
      <title>数组的概述</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Fri, 26 Feb 2021 19:29:11 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0/</guid>
      <description>数组的理解 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。
数组相关的概念  数组名 元素 角标、下标、索引 数组的长度：元素的个数  数组的特点  数组是有序排列的 数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型 创建数组对象会在内存中开辟一整块连续的空间 数组的长度一旦确定，就不能更改  数组的分类  按照维数：一维数组、二维数组、&amp;hellip; 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组  数据结构 数据与数据之间的逻辑关系 集合、一对一、一对多、多对多</description>
    </item>
    
    <item>
      <title>分支结构</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 26 Feb 2021 16:10:35 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</guid>
      <description>if-else条件判断结构 三种结构  结构一  if (条件表达式) {执行表达式}  结构二：二选一  if (条件表达式) {执行表达式1} else {执行表达式2}  结构三  if (条件表达式) {执行表达式1} else if (条件表达式) {执行表达式2} else if (条件表达式) {执行表达式3}.</description>
    </item>
    
    <item>
      <title>算术运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 14:57:21 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>算术运算符 + - * / % (前)++ (后)++ (前)&amp;ndash; (后)&amp;ndash;</description>
    </item>
    
    <item>
      <title>代码简洁之道</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</link>
      <pubDate>Fri, 26 Feb 2021 12:19:58 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E6%A0%87%E8%AF%86%E7%AC%A6/%E4%BB%A3%E7%A0%81%E7%AE%80%E6%B4%81%E4%B9%8B%E9%81%93/</guid>
      <description>有意义的命名 介绍 软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名。 这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。</description>
    </item>
    
    <item>
      <title>Java语言概述</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Wed, 24 Feb 2021 12:29:00 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</guid>
      <description>Java语言概述 基础常识  软件：即一系列按照特定顺序组织的计算机数据和指令的集合，系统软件和应用软件  系统软件：windows , mac os , linux ,unix,android,ios,&amp;hellip;.</description>
    </item>
    
    <item>
      <title>Class类的理解与获取Class的实例</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Wed, 21 Apr 2021 14:38:27 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E8%8E%B7%E5%8F%96class%E7%9A%84%E5%AE%9E%E4%BE%8B/</guid>
      <description>Class类的理解 类的加载过程：
程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此 运行时类，就作为Class的一个实例</description>
    </item>
    
    <item>
      <title>TCP网络编程</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 21 Apr 2021 13:59:00 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>代码示例一 客户端发送信息给服务端，服务端将数据显示在控制台上
//客户端 @Test public void client() { Socket socket = null; OutputStream os = null; try { //1.</description>
    </item>
    
    <item>
      <title>IO流概述</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/io%E6%B5%81%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 20 Apr 2021 17:32:10 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/io%E6%B5%81%E6%A6%82%E8%BF%B0/</guid>
      <description>流的分类  操作数据单位：字节流、字符流 数据的流向：输入流、输出流 流的角色：节点流、处理流  图示：</description>
    </item>
    
    <item>
      <title>泛型在集合中的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 19 Apr 2021 17:59:21 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>在集合中使用泛型之前的例子 @Test public void test1(){ ArrayList list = new ArrayList(); //需求：存放学生的成绩 list.</description>
    </item>
    
    <item>
      <title>Collection接口</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 10 Apr 2021 10:30:40 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E6%8E%A5%E5%8F%A3/</guid>
      <description>单列集合框架结构  Collection接口：单列集合，用来存储一个一个的对象  List接口：存储有序的、可重复的数据  ArrayList、LinkedList、Vector   Set接口：存储无序的、不可重复的数据  HashSet、LinkedHashSet、TreeSet      对应图示：</description>
    </item>
    
    <item>
      <title>注解的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 09 Apr 2021 12:02:47 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>注解的理解  JDK 5.</description>
    </item>
    
    <item>
      <title>StringBuffer、StringBuilder</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/stringbufferstringbuilder/</link>
      <pubDate>Mon, 05 Apr 2021 14:58:37 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/stringbufferstringbuilder/</guid>
      <description>String、StringBuffer、StringBuilder三者的对比 String：不可变的字符序列，底层使用char[]存储
StringBuffer：可变的字符序列；线程安全的，效率低；底层使用char[]存储</description>
    </item>
    
    <item>
      <title>并行与并发</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Thu, 01 Apr 2021 20:38:22 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91/</guid>
      <description>单核CPU与多核CPU的理解  单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）但是因为CPU时间单元特别短，因此感觉不出来 如果是多核的话，才能更好的发挥多线程的效率（现在的服务器都是多核的） 一个Java应用程序java.</description>
    </item>
    
    <item>
      <title>异常的处理</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 31 Mar 2021 23:30:02 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86/</guid>
      <description>Java异常处理的抓抛模型  过程一：  &amp;ldquo;抛&amp;rdquo;：  程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行   关于异常对象的产生：  系统自动生成的异常对象 手动的生成一个异常对象，并抛出（throw）     过程二：  &amp;ldquo;抓&amp;rdquo;：  可以理解为异常的处理方式：①try-catch-finally ②throws      异常处理方式一：try-catch-finally 使用说明 try{ //可能出现异常的代码 }catch(异常类型1 变量名1){ //处理异常的方式1 }catch(异常类型2 变量名2){ //处理异常的方式2 }catch(异常类型3 变量名3){ //处理异常的方式3 } .</description>
    </item>
    
    <item>
      <title>工厂的设计模式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E5%B7%A5%E5%8E%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Mar 2021 21:11:09 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E5%B7%A5%E5%8E%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决的问题 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的
具体模式  简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品) 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)  </description>
    </item>
    
    <item>
      <title>方法的重写</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/</link>
      <pubDate>Sat, 27 Mar 2021 15:42:27 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99/</guid>
      <description>什么是方法的重写(override)？ 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
应用 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</description>
    </item>
    
    <item>
      <title>JavaBean的概念</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/javabean%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Thu, 25 Mar 2021 20:43:58 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/javabean%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>所谓JavaBean，是指符合如下标准的Java类
 类是公共的 一个无参的公共的构造器 属性，且对应的get、set方法  </description>
    </item>
    
    <item>
      <title>方法的重载</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/</link>
      <pubDate>Sat, 27 Feb 2021 13:35:02 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD/</guid>
      <description>方法的重载的概念 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可
总结：&amp;ldquo;两同一不同&amp;rdquo;</description>
    </item>
    
    <item>
      <title>类的结构之一：属性</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%80%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Fri, 26 Feb 2021 23:23:20 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%80%E5%B1%9E%E6%80%A7/</guid>
      <description>类的设计中，两个重要结构之一：属性 对比：属性 vs 局部变量</description>
    </item>
    
    <item>
      <title>一维数组</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 26 Feb 2021 19:37:22 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>一维数组的声明与初始化 正确的方式：
int num;//声明num = 10;//初始化int id = 1001;//声明 + 初始化int[] ids;//声明//1.</description>
    </item>
    
    <item>
      <title>循环结构</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</link>
      <pubDate>Fri, 26 Feb 2021 16:21:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</guid>
      <description>循环结构的四要素  ①初始化条件 ②循环条件 &amp;mdash;&amp;gt; 是boolean类型 ③循环体 ④迭代条件  说明：通常情况下，循环结束都是因为②中循环条件返回false了。</description>
    </item>
    
    <item>
      <title>赋值运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 15:06:15 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>赋值运算符 = += -= *= /= %=</description>
    </item>
    
    <item>
      <title>变量的使用（重点）</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E9%87%8D%E7%82%B9/</link>
      <pubDate>Fri, 26 Feb 2021 13:57:31 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E9%87%8D%E7%82%B9/</guid>
      <description>变量的分类 按数据类型分类 详细说明：</description>
    </item>
    
    <item>
      <title>开发环境的搭建</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 24 Feb 2021 12:39:54 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</guid>
      <description>开发环境的搭建（重点） JDK、JRE、JVM的关系 JDK的下载、安装  下载：官网，github 安装：傻瓜式安装：JDK、JRE （安装软件的路径中不能包含中文、空格）  path环境变量的配置 为什么配置path环境变量？ path环境变量：windows操作系统执行命令时所要搜寻的路径 为什么要配置path:希望java的开发工具（javac.</description>
    </item>
    
    <item>
      <title>了解ClassLoader</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E4%BA%86%E8%A7%A3classloader/</link>
      <pubDate>Wed, 21 Apr 2021 14:56:53 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E4%BA%86%E8%A7%A3classloader/</guid>
      <description>类的加载过程 类的加载过程 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口</description>
    </item>
    
    <item>
      <title>UDP网络编程</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 21 Apr 2021 14:14:54 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/udp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>代码示例 //发送端 @Test public void sender() throws IOException { DatagramSocket socket = new DatagramSocket(); String str = &amp;quot;我是UDP方式发送的导弹&amp;quot;; byte[] data = str.</description>
    </item>
    
    <item>
      <title>节点流（或文件流）</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E8%8A%82%E7%82%B9%E6%B5%81%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81/</link>
      <pubDate>Tue, 20 Apr 2021 18:04:40 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E8%8A%82%E7%82%B9%E6%B5%81%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81/</guid>
      <description>FileReader / FileWriter的使用 FIleReader的使用 /* 说明点： 1.</description>
    </item>
    
    <item>
      <title>自定义泛型类、泛型接口、泛型方法</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 19 Apr 2021 18:22:09 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</guid>
      <description>举例 Order.java
public class Order&amp;lt;T&amp;gt; { String orderName; int orderId; //类的内部结构就可以使用类的泛型 T orderT; public Order(){ //编译不通过 // T[] arr = new T[10]; //编译通过 T[] arr = (T[]) new Object[10]; } public Order(String orderName,int orderId,T orderT){ this.</description>
    </item>
    
    <item>
      <title>Iterator接口与foreach循环</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/iterator%E6%8E%A5%E5%8F%A3%E4%B8%8Eforeach%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 11 Apr 2021 00:31:17 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/iterator%E6%8E%A5%E5%8F%A3%E4%B8%8Eforeach%E5%BE%AA%E7%8E%AF/</guid>
      <description>遍历Collection的两种方式  使用迭代器Iterator foreach循环（或增强for循环）  java.</description>
    </item>
    
    <item>
      <title>JDK 8之前日期时间API</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/jdk8%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/</link>
      <pubDate>Mon, 05 Apr 2021 23:30:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/jdk8%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/</guid>
      <description>获取系统当前时间 System类中的currentTimeMillis()
long time = System.</description>
    </item>
    
    <item>
      <title>创建多线程的两种方式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Thu, 01 Apr 2021 22:02:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
      <description>方式一：继承Thread类的方式  创建一个继承于Thread类的子类 重写Thread类的run() &amp;mdash;&amp;gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start()：①启动当前线程 ②调用当前线程的run()  说明两个问题：</description>
    </item>
    
    <item>
      <title>手动抛出异常对象</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 01 Apr 2021 19:50:12 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1/</guid>
      <description>使用说明 在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象
典型例题 class Student{ private int id; public void regist(int id) throws Exception { if(id &amp;gt; 0){ this.</description>
    </item>
    
    <item>
      <title>关键字：final</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97final/</link>
      <pubDate>Sun, 28 Mar 2021 15:15:16 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97final/</guid>
      <description>final：最终的 可以用来修饰：类、方法、变量
final 用来修饰一个类：此类不能被其他类所继承 比如：String类、System类、StringBuffer</description>
    </item>
    
    <item>
      <title>关键字：super</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%85%B3%E9%94%AE%E5%AD%97super/</link>
      <pubDate>Sat, 27 Mar 2021 16:19:12 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%85%B3%E9%94%AE%E5%AD%97super/</guid>
      <description>super关键字的理解 super 关键字可以理解为：父类的</description>
    </item>
    
    <item>
      <title>可变个数形参的方法</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 27 Feb 2021 13:43:38 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%BD%A2%E5%8F%82%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>使用说明  jdk 5.</description>
    </item>
    
    <item>
      <title>二维数组</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 26 Feb 2021 19:44:18 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</guid>
      <description>如何理解二维数组？  数组属于引用数据类型 数组的元素也可以是引用数据类型 一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。  二维数组的声明与初始化 正确的法式：</description>
    </item>
    
    <item>
      <title>关键字break和continue</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%85%B3%E9%94%AE%E5%AD%97break%E5%92%8Ccontinue/</link>
      <pubDate>Fri, 26 Feb 2021 16:55:39 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/%E5%85%B3%E9%94%AE%E5%AD%97break%E5%92%8Ccontinue/</guid>
      <description>break和continue关键字的使用    关键字 使用范围 循环中使用的作用(不同点) 相同点     break ①switch-case②循环结构中 结束当前循环 关键字后面不能声明执行语句   continue 循环结构中 结束本次循环 关键字后面不能声明执行语句    </description>
    </item>
    
    <item>
      <title>比较运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 15:10:02 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>比较运算符（关系运算符） == != &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= instanceof</description>
    </item>
    
    <item>
      <title>进制（了解）</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6%E4%BA%86%E8%A7%A3/</link>
      <pubDate>Fri, 26 Feb 2021 14:33:45 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%9B%E5%88%B6%E4%BA%86%E8%A7%A3/</guid>
      <description>编程中涉及的进制及表示方式 二进制的使用说明  计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。 二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。 原码、反码、补码的说明：  正数：三码合一 负数：  原码：直接将一个数值转换成二进制数，最高位是符号位 负数的反码：是对原码按位取反，只是最高位（符号位）确定为1 负数的补码：其反码加1      进制间的转换  图示： 图示二进制转换为十进制： 图示十进制转换为二进制： 二进制与八进制、十六进制间的转换：  </description>
    </item>
    
    <item>
      <title>第一个Java程序</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Wed, 24 Feb 2021 14:02:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/</guid>
      <description>开发体验——HelloWorld 编写 创建一个java源文件：HelloWorld.javapublic class HelloWorld{public static void main(String[] args){System.</description>
    </item>
    
    <item>
      <title>反射应用一：创建运行时类的对象</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%B8%80%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Wed, 21 Apr 2021 15:15:42 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%B8%80%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1/</guid>
      <description>代码举例 Class&amp;lt;Person&amp;gt; clazz = Person.</description>
    </item>
    
    <item>
      <title>URL编程</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/url%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Wed, 21 Apr 2021 14:19:07 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/url%E7%BC%96%E7%A8%8B/</guid>
      <description>URL(Uniform Resource Locator)的理解 统一资源定位符，对应着互联网的某一资源地址</description>
    </item>
    
    <item>
      <title>缓冲流的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Apr 2021 18:24:01 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>缓冲流涉及到的类  BufferedInputStream BufferedOutputStream BufferedReader BUfferedWriter  作用 提高流的读取、写入的速度</description>
    </item>
    
    <item>
      <title>泛型在继承上的体现</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0/</link>
      <pubDate>Mon, 19 Apr 2021 23:18:37 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0/</guid>
      <description>泛型在继承上的体现 虽然类A是类B的父类，但是G&amp;lt;A&amp;gt;和G&amp;lt;B&amp;gt;二者不具备子父类关系，二者是并列关系
类A是类B的父类，A&amp;lt;G&amp;gt;是B&amp;lt;G&amp;gt;的父类</description>
    </item>
    
    <item>
      <title>Collection子接口：List接口</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E5%AD%90%E6%8E%A5%E5%8F%A3list%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sun, 11 Apr 2021 14:01:07 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E5%AD%90%E6%8E%A5%E5%8F%A3list%E6%8E%A5%E5%8F%A3/</guid>
      <description>存储数据的特点 存储有序的、可重复的数据
常用方法  增：add(Object obj) 删：remove(int index) / remove(Object obj) 改：set(int index, Object obj) 查：get(int index) 插：add(int index, Object obj) 长度：size() 遍历：  Iterator迭代器方式 增强for循环 普通的循环    常用实现类  Collection接口：单列集合，用来存储一个一个的对象  List接口：存储有序的、可重复的数据  ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储      源码分析 ArrayList的源码分析 JDK 7 /** * ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData * list.</description>
    </item>
    
    <item>
      <title>JDK 8中新日期时间API</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/jdk8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/</link>
      <pubDate>Tue, 06 Apr 2021 12:16:35 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/jdk8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4api/</guid>
      <description>日期时间API的迭代 第一代：JDK 1.0 Date类</description>
    </item>
    
    <item>
      <title>Thread类中的常用方法</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 02 Apr 2021 00:47:24 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description>Thread类中的常用的方法  start()：启动当前线程，调用当前线程的run() run()：通常需要重写Thread类中的此方法，创建的线程要执行的操作声明在此方法中 currentThread()：静态方法，返回执行当前代码的线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 yield()：释放当前cpu的执行权 join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态 stop()：已过时，当执行此方法时，强制结束当前线程 sleep(long millitime)：让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态 isAlive()：判断当前线程是否存活  线程的优先级  MAX_PRIORITY：10 MIN _PRIORITY：1 NORM_PRIORITY：5 &amp;ndash;&amp;gt; 默认优先级  如何获取和设置当前线程的优先级  getPriority()：获取线程的优先级 setPriority(int p)：设置线程的优先级  说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行</description>
    </item>
    
    <item>
      <title>自定义异常类</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/</link>
      <pubDate>Thu, 01 Apr 2021 19:54:18 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/</guid>
      <description>如何自定义一个异常类  继承于现的异常结构：RuntimeException 、Exception 提供全局常量：serialVersionUID 提供重载的构造器  public class MyException extends Exception{ static final long serialVersionUID = -7034897193246939L; public MyException(){ } public MyException(String msg){ super(msg); } }  </description>
    </item>
    
    <item>
      <title>子类对象实例化全过程</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sat, 27 Mar 2021 16:53:14 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%85%A8%E8%BF%87%E7%A8%8B/</guid>
      <description>从结果上看：继承性  子类继承父类以后，就获取了父类中声明的属性或方法 创建子类的对象，在堆空间中，就会加载所父类中声明的属性  从过程上看 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，&amp;hellip;直到调用了java.</description>
    </item>
    
    <item>
      <title>Java的值传递机制</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 27 Feb 2021 13:57:20 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/java%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <description>针对于方法内变量的赋值举例 System.out.println(&amp;quot;***********基本数据类型：****************&amp;quot;);int m = 10;int n = m;System.</description>
    </item>
    
    <item>
      <title>数组的常见算法</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 26 Feb 2021 19:54:54 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</guid>
      <description>数组的创建与元素赋值 杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。
针对于数值型的数组 最大值、最小值、总和、平均数等</description>
    </item>
    
    <item>
      <title>逻辑运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 15:36:23 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>逻辑运算符 &amp;amp;(逻辑与) &amp;amp;&amp;amp;(短路与) |(逻辑或) ||(短路或) !</description>
    </item>
    
    <item>
      <title>注释与API文档等</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E6%B3%A8%E9%87%8A%E4%B8%8Eapi%E6%96%87%E6%A1%A3%E7%AD%89/</link>
      <pubDate>Wed, 24 Feb 2021 14:05:16 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/%E6%B3%A8%E9%87%8A%E4%B8%8Eapi%E6%96%87%E6%A1%A3%E7%AD%89/</guid>
      <description>注释:Comment  分类：  单行注释：// 多行注释：/* */ 文档注释：/** */   作用：  对所写的程序进行解释说明，增强可读性。方便自己，方便别人 调试所写的代码   特点：  单行注释和多行注释，注释了的内容不参与编译。换句话说，编译以后生成的.</description>
    </item>
    
    <item>
      <title>反射应用二：获取运行时类的完整结构</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%BA%8C%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 21 Apr 2021 15:20:36 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%BA%8C%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84/</guid>
      <description>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。。
典型代码 @Test public void test1(){ Class clazz = Person.</description>
    </item>
    
    <item>
      <title>通配符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E9%80%9A%E9%85%8D%E7%AC%A6/</link>
      <pubDate>Mon, 19 Apr 2021 23:28:59 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E6%B3%9B%E5%9E%8B/%E9%80%9A%E9%85%8D%E7%AC%A6/</guid>
      <description>通配符的使用 /* 通配符的使用 通配符：?</description>
    </item>
    
    <item>
      <title>Collection子接口：Set接口</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E5%AD%90%E6%8E%A5%E5%8F%A3set%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sun, 11 Apr 2021 15:38:48 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collection%E5%AD%90%E6%8E%A5%E5%8F%A3set%E6%8E%A5%E5%8F%A3/</guid>
      <description>存储的数据特点 无序的、不可重复的元素
具体的：以HashSet为例说明</description>
    </item>
    
    <item>
      <title>Java比较器</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/java%E6%AF%94%E8%BE%83%E5%99%A8/</link>
      <pubDate>Tue, 06 Apr 2021 22:29:57 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/java%E6%AF%94%E8%BE%83%E5%99%A8/</guid>
      <description>Java比较器的使用背景 Java中的对象，正常情况下，只能进行比较：== 或 !</description>
    </item>
    
    <item>
      <title>Thread的生命周期</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</link>
      <pubDate>Fri, 02 Apr 2021 10:38:44 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/thread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</guid>
      <description>图示 说明  生命周期关注两个概念：状态、相应的方法 关注状态a &amp;mdash;&amp;gt; 状态b，哪些方法执行了（回调方法），某个方法主动调用：状态a &amp;mdash;&amp;gt; 状态b 阻塞：临时状态，不可以作为最终状态 死亡：最终状态  </description>
    </item>
    
    <item>
      <title>面向对象的特征三：多态性</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%89%E5%A4%9A%E6%80%81%E6%80%A7/</link>
      <pubDate>Sat, 27 Mar 2021 16:59:18 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%89%E5%A4%9A%E6%80%81%E6%80%A7/</guid>
      <description>多态性的理解 可以理解为一个事物的多种形态
何为多态性 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</description>
    </item>
    
    <item>
      <title>面向对象的特征一：封装性</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%80%E5%B0%81%E8%A3%85%E6%80%A7/</link>
      <pubDate>Thu, 25 Mar 2021 19:34:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B8%80%E5%B0%81%E8%A3%85%E6%80%A7/</guid>
      <description>面向对象的特征一：封装与隐藏 为什么要引入封装性？  我们程序设计追求“高内聚，低耦合”  高内聚：类的内部数据操作细节自己完成，不允许外部干涉 低耦合 ：仅对外暴露少量的方法用于使用   隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想  问题引入 当我们创建一个类的对象以后，我们可以通过&amp;quot;对象.</description>
    </item>
    
    <item>
      <title>递归方法</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 27 Feb 2021 14:09:38 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95/</guid>
      <description>定义 递归方法：一个方法体内调用它自身。
如何理解递归方法  方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环  举例 // 例1：计算1-n之间所自然数的和public int getSum(int n) {if (n == 1) {return n;}return n + (getSum(n - 1));}// 例2：计算1-n之间所自然数的乘积:n!</description>
    </item>
    
    <item>
      <title>Arrays工具类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 26 Feb 2021 20:26:19 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>理解  定义在java.util包下 Arrays:提供了很多操作数组的方法  使用 //1.</description>
    </item>
    
    <item>
      <title>位运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 15:40:29 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>位运算符 &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;gt;&amp;gt;&amp;gt; &amp;amp; | ^ ~</description>
    </item>
    
    <item>
      <title>反射应用三：调用运行时类的指定结构</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%B8%89%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 21 Apr 2021 15:36:32 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E4%B8%89%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84/</guid>
      <description>调用指定的属性 @Test public void testField1() throws Exception { Class clazz = Person.</description>
    </item>
    
    <item>
      <title>其它的流的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E5%85%B6%E5%AE%83%E7%9A%84%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Apr 2021 23:26:01 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E5%85%B6%E5%AE%83%E7%9A%84%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>标准的输入输出流 System.in：标准的输入流，默认从键盘输入
System.out：标准的输出流，默认从控制台输出</description>
    </item>
    
    <item>
      <title>Map接口</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/map%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 16 Apr 2021 11:30:10 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/map%E6%8E%A5%E5%8F%A3/</guid>
      <description>常用实现类结构   Map：双列数据，存储key-value对的数据</description>
    </item>
    
    <item>
      <title>其他类</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%85%B6%E4%BB%96%E7%B1%BB/</link>
      <pubDate>Tue, 06 Apr 2021 23:01:03 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%B8%B8%E7%94%A8%E7%B1%BB/%E5%85%B6%E4%BB%96%E7%B1%BB/</guid>
      <description>System类  System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用 方法  native long currentTimeMills() void exit(int status) void gc() String getProperty(String key)    Math类 java.</description>
    </item>
    
    <item>
      <title>类的结构：内部类</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E7%B1%BB/</link>
      <pubDate>Tue, 30 Mar 2021 21:14:05 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%E5%86%85%E9%83%A8%E7%B1%BB/</guid>
      <description>内部类 类的第五个成员
定义 Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</description>
    </item>
    
    <item>
      <title>Object类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 27 Mar 2021 17:51:19 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/object%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>java.lang.Object类的说明  Object类是所Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.</description>
    </item>
    
    <item>
      <title>关键字：this</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E5%85%B3%E9%94%AE%E5%AD%97this/</link>
      <pubDate>Fri, 26 Mar 2021 19:22:47 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E5%85%B3%E9%94%AE%E5%AD%97this/</guid>
      <description>可以调用的结构 属性、方法、构造器
this调用属性、方法 this理解为：当前对象 或 当前正在创建的对象</description>
    </item>
    
    <item>
      <title>数组的常见异常</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Fri, 26 Feb 2021 20:30:39 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/</guid>
      <description>数组角标越界异常 ArrayIndexOutOfBoundsException
int[] arr = new int[]{1,2,3,4,5}; for(int i = 0;i &amp;lt;= arr.</description>
    </item>
    
    <item>
      <title>三元运算符</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Fri, 26 Feb 2021 15:44:46 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>三元运算符 (条件表达式)? 表达式1 : 表达式2</description>
    </item>
    
    <item>
      <title>反射应用四：动态代理</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E5%9B%9B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Wed, 21 Apr 2021 15:41:31 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E5%9B%9B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>代理模式的原理 使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上
静态代理 举例 //实现Runnable接口的方法创建多线程。 Class MyThread implements Runnable{} //相当于被代理类 Class Thread implements Runnable{} //相当于代理类 main() { MyThread t = new MyThread(); Thread thread = new Thread(t); thread.</description>
    </item>
    
    <item>
      <title>对象流的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Apr 2021 23:35:15 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>对象流 ObjectInputStream和ObjectOutputStream
作用 ObjectOutputStream：内存中的对象 &amp;mdash;&amp;gt; 存储中的文件、通过网络传输出去（序列化过程）</description>
    </item>
    
    <item>
      <title>Collections工具类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 18 Apr 2021 11:28:45 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/java%E9%9B%86%E5%90%88/collections%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>Collections工具类 作用：操作Collection和Map的工具类
常用方法：</description>
    </item>
    
    <item>
      <title>线程通信</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Fri, 02 Apr 2021 11:43:31 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</guid>
      <description>线程通信涉及到的三个方法  wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器 notify()：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个 notifyAll()：一旦执行此方法，就会唤醒所有被wait的线程  说明  wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常 wait()，notify()，notifyAll()三个方法是定义在java.</description>
    </item>
    
    <item>
      <title>包装类的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 28 Mar 2021 12:44:22 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>为什么要有包装类(或封装类） 为了使基本数据类型的变量具有类的特征，引入包装类
基本数据类型与对应的包装类    基本数据类型 包装类     byte Byte   short Short   int Integer   long Long   float Float   double Double   boolean Boolean   char Character    需要掌握的类型间的转换：（基本数据类型、包装类、String） 基本数据类型&amp;lt;&amp;mdash;&amp;gt;包装类：JDK 5.</description>
    </item>
    
    <item>
      <title>关键字：package、import</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E5%85%B3%E9%94%AE%E5%AD%97packageimport/</link>
      <pubDate>Fri, 26 Mar 2021 19:51:19 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/%E5%85%B3%E9%94%AE%E5%AD%97packageimport/</guid>
      <description>package的使用  为了更好的实现项目中类的管理，提供包的概念 使用package声明类或接口所属的包，声明在源文件的首行 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)&amp;ldquo;见名知意&amp;rdquo; 每&amp;quot;.</description>
    </item>
    
    <item>
      <title>RandomAccessFile的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/randomaccessfile%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 20 Apr 2021 23:59:51 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/randomaccessfile%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>随机存取文件流 RandomAccessFile
使用说明  RandomAccessFile直接继承于java.</description>
    </item>
    
    <item>
      <title>JDK5.0新增线程创建的方式</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/jdk5.0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 04 Apr 2021 18:10:26 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/jdk5.0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>新增方式一：实现Callable接口 //1.创建一个实现Callable的实现类 class NumThread implements Callable{ //2.</description>
    </item>
    
    <item>
      <title>Path、Paths、Files的使用</title>
      <link>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/pathpathsfiles%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 21 Apr 2021 00:20:12 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/docs/java_se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/io%E6%B5%81/pathpathsfiles%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>NIO的使用说明 Java NIO（new IO / Non-Blocking IO）是从Java 1.</description>
    </item>
    
    <item>
      <title>Git中对于删除首次提交的看法</title>
      <link>https://ObitoSnn.github.io/posts/git%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%88%A0%E9%99%A4%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E7%9C%8B%E6%B3%95/</link>
      <pubDate>Sun, 06 Jun 2021 00:59:05 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/git%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%88%A0%E9%99%A4%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E7%9C%8B%E6%B3%95/</guid>
      <description>update-ref指令：
git update-ref -d HEAD 它将删除命名引用。HEAD，所以它会重新设置(轻轻地，不会丢失工作当前分支的所有提交</description>
    </item>
    
    <item>
      <title>Linux（CentOS7）安装JDK、MySQL、Tomcat</title>
      <link>https://ObitoSnn.github.io/posts/linuxcentos7%E5%AE%89%E8%A3%85jdkmysqltomcat/</link>
      <pubDate>Sun, 25 Apr 2021 15:35:56 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/linuxcentos7%E5%AE%89%E8%A3%85jdkmysqltomcat/</guid>
      <description>前言 为了模拟远程操作，在Windows环境下使用远程工具连接Linux，所以在正式安装前需要准备两个远程工具(Xshell和Xftp)，使用Xshell远程控制Linux，使用Xftp将文件传输至Linux。当然你也可以直接在Linux中下载所需文件
安装JDK JDK官网下载地址 JDK 8</description>
    </item>
    
    <item>
      <title>浅谈Map</title>
      <link>https://ObitoSnn.github.io/posts/%E6%B5%85%E8%B0%88map/</link>
      <pubDate>Wed, 24 Feb 2021 14:19:01 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/%E6%B5%85%E8%B0%88map/</guid>
      <description>Map接口 双列集合，用来存储一对(key - value)一对的数据</description>
    </item>
    
    <item>
      <title>JDBC——针对不同表的通用查询操作，返回多条数据</title>
      <link>https://ObitoSnn.github.io/posts/jdbc%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Wed, 24 Feb 2021 14:17:11 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/jdbc%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8C%E8%A1%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C%E8%BF%94%E5%9B%9E%E5%A4%9A%E6%9D%A1%E6%95%B0%E6%8D%AE/</guid>
      <description>思路： ① 获取连接 ② 预编译SQL返回PreparedStatement实例 ③ 处理占位符 ④ 执行操作返回ResultSet并处理结果集 ⑤ 关闭资源</description>
    </item>
    
    <item>
      <title>Java 反射机制——动态代理举例</title>
      <link>https://ObitoSnn.github.io/posts/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%BE%E4%BE%8B/</link>
      <pubDate>Wed, 24 Feb 2021 14:15:32 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%BE%E4%BE%8B/</guid>
      <description>思路： 实现动态代理需要解决的问题： 问题一：如何根据内存中加载的被代理类，动态的创建代理类及其对象。 问题二：当代理类的对象调用方法a时，如何动态的调用被代理类中声明的方法a。</description>
    </item>
    
    <item>
      <title>Java TCP网络编程——客户端发送文件给服务端，服务端将文件保存在本地</title>
      <link>https://ObitoSnn.github.io/posts/java-tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%9C%AC%E5%9C%B0/</link>
      <pubDate>Wed, 24 Feb 2021 14:10:11 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/java-tcp%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%9C%AC%E5%9C%B0/</guid>
      <description>思路： ①创建客户端Socket与服务端ServerSocket；调用相应的get方法获取流； ②处理数据：先确定要处理的数据(文本文件、非文本文件或字符串)，确定后考虑使用相应的流处理。补充：本次以处理图片为例(非文本文件)。 ③关闭资源。</description>
    </item>
    
    <item>
      <title>Object类概述</title>
      <link>https://ObitoSnn.github.io/posts/object%E7%B1%BB%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 23 Feb 2021 22:22:48 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/object%E7%B1%BB%E6%A6%82%E8%BF%B0/</guid>
      <description>Object类概述 Object在java.lang包下，Object类是所有类的根类。每个类都使用 Object 作为父类(超类)</description>
    </item>
    
    <item>
      <title>Java IO流——获取文本上字符出现的次数,把数据写入文件</title>
      <link>https://ObitoSnn.github.io/posts/java-io%E6%B5%81%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8A%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 23 Feb 2021 22:22:30 +0800</pubDate>
      
      <guid>https://ObitoSnn.github.io/posts/java-io%E6%B5%81%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E4%B8%8A%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</guid>
      <description>思路： ①创建文件及相应的流。 ②处理数据：读入和写出。补充：处理文本中字符出现的次数(方式一：将文本文件的字符添加到list，再将字符作为key存入map中，value为字符出现次数；方式二：也可以直接将读入字符存入map中) ③关闭资源。</description>
    </item>
    
  </channel>
</rss>
