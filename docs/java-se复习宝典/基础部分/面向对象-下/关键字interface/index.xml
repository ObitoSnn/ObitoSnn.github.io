<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>关键字：interface on 主页</title>
    <link>https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/</link>
    <description>Recent content in 关键字：interface on 主页</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;javascript:void(0);&#34;&gt;ObitoSnn&lt;/a&gt;
</copyright>
    <lastBuildDate>Tue, 30 Mar 2021 20:33:42 +0800</lastBuildDate><atom:link href="https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>代理模式</title>
      <link>https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Mar 2021 21:03:41 +0800</pubDate>
      
      <guid>https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决的问题 代理模式是Java开发中使用较多的一种设计模式，代理设计就是为其他对象提供一种代理以控制对这个对象的访问
举例 interface NetWork{ public void browse(); } //被代理类 class Server implements NetWork{ @Override public void browse() { System.</description>
    </item>
    
    <item>
      <title>工厂的设计模式</title>
      <link>https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E5%B7%A5%E5%8E%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Mar 2021 21:11:09 +0800</pubDate>
      
      <guid>https://ObitoSnn.gitee.io/docs/java-se%E5%A4%8D%E4%B9%A0%E5%AE%9D%E5%85%B8/%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/%E5%85%B3%E9%94%AE%E5%AD%97interface/%E5%B7%A5%E5%8E%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>解决的问题 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的
具体模式  简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码） 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品) 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)  </description>
    </item>
    
  </channel>
</rss>
